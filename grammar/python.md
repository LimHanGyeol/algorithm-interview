# 파이썬 문법

## 인덴트 (Indent)
* 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 한다.
* 코드 첫 번째 줄에 파라미터가 있다면, 파라미터가 시작되는 부분에 맞춘다.
* 코드 첫 번째 줄에 파라미터가 없다면, 공백 4칸 인덴트를 한 번 더 추가하여 다른 행과 구분되게 한다.

## 네이밍 컨벤션
* 파이썬의 네이밍 컨벤션은 자바와 달리 각 단어를 하이픈(_)으로 구분하여 표기하는 스네이크 케이스(Snake Case)를 따른다.
* 파이썬은 Pythonic Way를 준수하여 카멜 케이스 뿐만 아니라 자바 스타일의 컨벤션을 지양한다.
* 컨벤션으로 인한 질문을 받게 되면 "파이썬의 PEP 8 및 철학에 따라 스네이크 코딩을 지향한다."라고 답할 수 있어야 한다.

## 타입 힌트 (Type Hint)
* 파이썬은 대표적인 동적 타이핑 언어임에도, 타입을 지정할 수 있는 Type Hint 가 PEP 484 문서에 추가됐다.
* 해당 기능은 파이썬 3.5 버전 부터 사용할 수 있다.
* 파이썬의 타입 추론은 빠르게 정의해서 사용할 수 있는 장점이 있지만, 파라미터의 타입과 리턴값이 무엇인지 알 수 없다.  
프로젝트 규모가 커지게 되면 가독성을 떨어트리게 되며 버그 유발의 주범이 된다.  
타입 힌트를 사용하면 파라미터 및 리턴 타입을 분명하게 알 수 있다. 가독성도 좋아지며 버그 발생 확률을 줄일 수 있다.
* 실제로는 강제 규약이 아니다 보니, 여전히 동적으로 할당될 수 있으므로 주의가 필요하다.
* 코딩 테스트는 일반적으로 짧은 알고리즘으로 끝나는 경우가 많고, 타입은 지정하지 않아도 한눈에 보일 만큼 명확하기 때문에 굳이 지정하지 않아도 문제는 없다.  
그러나 코드를 정리할 때만이라도 타입을 모두 지정해서 보기좋게 제출한다면, 코드 리뷰 시 면접관에게 좋은 점수를 받을 수 있을 것이다.

## 리스트 컴프리헨션
* 파이썬은 map, filter 와 같은 함수형 (Functional) 기능을 지원하며 람다 표현식 (Lambda Expression) 도 지원한다.
* 리스트 컴프리헨션 (List Comprehension) 이란 기존 리스트를 기반으로 새로운 리스트를 만들어 내는 구문으로,  
파이썬 2.0 부터 지원 되었으며, 하스켈 (Haskell) 같은 함수형 언어에서 기능을 차용해온 파이썬의 대표적인 특징이기도 하다.
* 리스트 컴프리헨션이 리스트만 가능한 것은 아니다. 버전 2.7 이후 리스트 외에도 딕셔너리 등이 가능하도록 추가됐다.
* 한 줄로 간결하게 작성할 수 있는 리스트 컴프리헨션은 가독성이 좋은 편이지만 이 또한 무리하고 복잡하게 작성할 경우 가독성을 떨어트릴 수 있으므로 적절히 사용하는 게 중요하다.  
대체로 표현식은 2개를 넘지 않아야 한다.

## 제너레이터 (Generator)
* 제너레이터 (Generator)는 파이썬 2.2에 출시한 루프의 반복 동작을 제어할 수 있는 루틴 형태를 말한다.
* yield 구문을 사용하면 제너레이터를 리턴할 수 있다. yield 는 사전적으로 "양보하다" 라는 의미이다.  
기존의 함수는 return 구문을 만나면 값을 리턴하고 모든 함수의 동작을 종료한다.  
그러나 yield 는 제너레이터가 여기까지 실행 중이던 값을 내보낸다라는 의미로, 중간 값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행된다.

## Range
* 제너레이터의 방식을 활용하는 대표적인 함수이다. 주로 for문에서 사용된다.

## Enumerate
* enumerate() 는 '열거하다'라는 뜻의 함수로, 순서가 있는 자료형 (list, set, tuple 등) 을 인덱스를 포함한 enumerate 객체로 리턴한다.

## // 나눗셈 연산자
* 파이썬 2 이하에서 기본 나눗셈 연산자 /는 타입을 유지하는 특성 때문에 실수하기가 쉬웠다.  
5 / 3 을 했을때 기대하는 결과 값은 1.666... 이다. 파이썬 3 이상에서는 이와 같은 결과가 나온다.  
하지만 파이썬 2 이하 버전에서는 정수형을 유지하여 1을 리턴했다.
* PEP 238에서 이런 동작 방식의 변경이 제안 되었고, 이후 기본 나눗셈 연산자의 동작 방식이 변경되었다.
* PEP 238에서 이 외에도 타입을 유지하는 연산자로 // 연산자가 추가되었다.  
* // 연산자는 정수형을 나눗셈할 때 동일한 정수형을 결과로 리턴하면서 내림 (Floor Division) 연산자의 역할을 한다.  
다시 말해 몫 (Quotient)을 구하는 연산자이다.
* 나머지 (Remainder)를 구하는 연산자는 %이다.
& 몫과 나머지를 동시에 구하려면 divmod() 함수를 사용하면 된다.

## print
* 코딩 테스트 문제 풀이 과정에서 디버깅을 할 때 가장 자주 쓰는 명령은 print() 이다.
* 가장 값을 쉽게 출력하는 방법은 콤마(,)로 구분하는 것이다.  
> print('A1', 'B2') = A1 B2  
> print('A1', 'B2', seq=',') = A1,B2
* print() 함수는 항상 줄바꿈을 하기 때문에 긴 루프의 값을 반복적으로 출력하면 디버깅 하기가 어렵다.  
이 경우 end 파라미터를 공백으로 처리하여 줄바꿈을 하지 않도록 제한할 수 있다.
> print('aa', end=' ')  
> print('bb') = aa bb
* List를 출력할 때는 join()으로 묶어서 처리한다.
> a = ['A', 'B']  
> print(' '.join(a)) = A B
* idx와 fruit 이 정의되어 있을 때, idx 값에 1을 더해서 fruit 와 함께 출력하는 방법은 아래와 같다. 해당 인덱스는 생략할 수 있다.
> idx = 1  
> fruit = "Apple"  
> print('{0}: {1}'.format(idx + 1, fruit)) = 2: Apple
* f-string 방법도 선호되는 print 방식 중 하나이다.  
변수를 뒤에 별도로 부여할 필요 없이 템플릿 엔진을 사용하듯 인라인으로 삽입할 수 있어 편리하다.  
무엇보다 기존의 %를 사용하거나, .format 을 부여하는 방식에 비해 간결하고 직관적이며 속도도 빠르다.
* 하지만 f-string은 파이썬 3.6+ 에서만 지원한다. 이 점에 유의해야 한다.
> print(f'{idx + 1}: {fruit}') = 2: Apple

# pass
* 코딩을 할 때 코드의 전체 골격을 잡아 놓고 내부에서 처리할 내용을 차근차근 생각하며 만드는 경우가 있다.  
그럴 경우 인덴트 오류가 발생하는 경우가 있다. pass는 이런 오류를 막는 역할을 한다.
* 파이썬에서 pass 는 null 연산으로 아무것도 하지 않는 기능이다.  
이처럼 아무 역할을 하지 않는 pass를 지정하면, 앞서 발생한 인덴트 오류 같은 불필요한 오류를 방지할 수 있다.
* pass는 먼저 목업(mockup) 인터페이스부터 구현한 다음 추후 구현을 진행할 수 있게 한다. 코딩 테스트 시에도 유용하게 활용할 수 있다.

# locals
* locals()는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드로 업데이트 또한 가능하다.  
딕셔너리를 가져오는 부분에 집중해 살펴보자면, 우선 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명령이므로 디버깅에 많은 도움이 된다.
* 특히 로컬 스코프에 제한하여 정보를 조회할 수 있기 때문에 클래스의 특정 메소드 내부에서나 함수 내부의 로컬 정보를 조회해 잘못 선언한 부분이 없는지 확인하는 용도로 활용할 수 있다.
* 변수명을 일일이 찾아낼 필요 없이 로컬 스코프에 정의된 모든 변수를 출력하기 때문에 편리하다.
> import pprint  
> pprint.pprint(locals())
